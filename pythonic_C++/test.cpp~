#include <iostream>
#include <vector>
#include <chrono>

// used this timing method from http://stackoverflow.com/questions/2808398/easily-measure-elapsed-time

template<typename TimeT = std::chrono::microseconds>
struct measure
{
  template<typename F, typename ...Args>
  static typename TimeT::rep execution(F&& func, Args&&... args)
  {
    auto start = std::chrono::system_clock::now();
    std::forward<decltype(func)>(func)(std::forward<Args>(args)...);
    auto duration = std::chrono::duration_cast< TimeT> 
      (std::chrono::system_clock::now() - start);
    return duration.count();
  }
};


template<typename T>
std::vector<T> longVec(std::vector<T> v){
  //  return std::vector<T> a(v);
  return v;
}

template<typename T, typename... Args>
std::vector<T> longVec(std::vector<T> first, Args...args){
  auto v = longVec(first);
  auto rest = longVec(args...);
  v.insert(v.end(), rest.begin(), rest.end());
  return v;
}

int MAX = 1000;

// user defined string converstion "_s operator
struct op1 {
  void operator()() {
    for(int i = 0; i < MAX; i++){    
      //     auto v = longVec(4, 5, 6, 4, 4, 5, 5, 7, 2, 11, 12);
    }
  }
};


struct op2 {
  void operator()() {
    for(int i = 0; i < MAX; i++){    
      auto v2 = {4, 5, 6, 4, 4, 5, 5, 7, 2, 11, 12};
    }
  }
};


template<typename T>
void append_to_vector(std::vector<T>& v1, const std::vector<T>& v2) {
  std::cout << v2[0] << std::endl;
  for (auto& e : v2) v1.push_back(e);
}


template<typename T, typename... A>
std::vector<T> concat_version3(std::vector<T> v1, const A&... vr) {
    int unpack[] { (append_to_vector(v1, vr), 1)... };
    (void(unpack));
    return v1;
}

template <typename T>
void add_append(T t1, T t2){
  std::cout << t1+t2 << std::endl;
}

template<typename T, typename... A>
T adder(T a1, const A&...a2)
  int unpack[] {(add_append) ...};
  (void(unpack));



int main(){ 

  std::vector<std::vector<int>> VV;
  VV.emplace_back(std::initializer_list<int>{9, 9, 9, 9, 9, 9});
  VV.emplace_back(std::initializer_list<int>{1, 2, 3});
  VV.emplace_back(std::initializer_list<int>{5, 5, 5});

  auto big3 = concat_version3( VV[0], VV[1], VV[2]);
  std::cout << std::endl << std::endl << big3.size();
  std::cout << std::endl << std::endl << big3[6];

}

